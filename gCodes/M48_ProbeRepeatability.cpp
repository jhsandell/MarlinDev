#include "MarlinFirmware.h"

// Access the command line parameters
#include "parser.h"

// Access to the probe
#include "probe_management/probe_management.h"

// Access to motion management
#include "motion/motion.h"
#include "planner.h"

#include "host_interface/host_io.h"

#if ENABLED(USE_PROBE)

// This is redundant since the SanityCheck.h already checks for a valid Z_MIN_PROBE_PIN, but here for clarity.
#if ENABLED(Z_MIN_PROBE_ENDSTOP)
  #if !HAS_Z_PROBE
    #error You must define Z_MIN_PROBE_PIN to enable Z probe repeatability calculation.
  #endif
#elif !HAS_Z_MIN
  #error You must define Z_MIN_PIN to enable Z probe repeatability calculation.
#endif

/**
 * M48: Z probe repeatability measurement function.
 *
 * Usage:
 *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
 *     P = Number of sampled points (4-50, default 10)
 *     X = Sample X position
 *     Y = Sample Y position
 *     V = Verbose level (0-4, default=1)
 *     E = Engage Z probe for each reading
 *     L = Number of legs of movement before probe
 *     S = Schizoid (Or Star if you prefer)
 *
 * This function assumes the bed has been homed.  Specifically, that a G28 command
 * as been issued prior to invoking the M48 Z probe repeatability measurement function.
 * Any information generated by a prior G29 Bed leveling command will be lost and need to be
 * regenerated.
 */
void gcode_M48() {
  double sum = 0.0, mean = 0.0, sigma = 0.0, sample_set[50];
  uint8_t verbose_level = 1, n_samples = 10, n_legs = 0, schizoid_flag = 0;
  if (verbose_level > 0)
    SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test\n");
  if (code_seen('V')) {
    verbose_level = code_value_short();
    if (verbose_level < 0 || verbose_level > 4) {
      SERIAL_PROTOCOLPGM("?Verbose Level not plausible (0-4).\n");
      return;
    }
  }
  if (verbose_level > 0)
    SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test\n");
  if (code_seen('P')) {
    n_samples = code_value_short();
    if (n_samples < 4 || n_samples > 50) {
      SERIAL_PROTOCOLPGM("?Sample size not plausible (4-50).\n");
      return;
    }
  }
  float  X_current = current_position[X_AXIS],
         Y_current = current_position[Y_AXIS],
         Z_current = current_position[Z_AXIS],
         // E_current = current_position[E_AXIS],
         X_probe_location = X_current + X_PROBE_OFFSET_FROM_EXTRUDER,
         Y_probe_location = Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER,
         Z_start_location = Z_current + Z_RAISE_BEFORE_PROBING;
  bool deploy_probe_for_each_reading = code_seen('E');
  if (code_seen('X')) {
    X_probe_location = code_value();
    if (X_probe_location < X_MIN_POS || X_probe_location > X_MAX_POS) {
      out_of_range_error(PSTR("X"));
      return;
    }
  }
  if (code_seen('Y')) {
    Y_probe_location = code_value();
    if (Y_probe_location < Y_MIN_POS || Y_probe_location > Y_MAX_POS) {
      out_of_range_error(PSTR("Y"));
      return;
    }
  }
#if ENABLED(DELTA)
  if (sqrt(X_probe_location * X_probe_location + Y_probe_location * Y_probe_location) > DELTA_PROBEABLE_RADIUS) {
    SERIAL_PROTOCOLPGM("? (X,Y) location outside of probeable radius.\n");
    return;
  }
#endif
  if (code_seen('L')) {
    n_legs = code_value_short();
    if (n_legs == 1) n_legs = 2;
    if (n_legs < 0 || n_legs > 15) {
      SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");
      return;
    }
  }
  if (code_seen('S')) {
    schizoid_flag++;
    if (! code_seen('L'))
      n_legs = 7;
  }
  // Now get everything to the specified probe point So we can safely do a probe to
  // get us close to the bed.  If the Z-Axis is far from the bed, we don't want to
  // use that as a starting point for each probe.
  //
  if (verbose_level > 2)
    SERIAL_PROTOCOLPGM("Positioning the probe...\n");
#if DISABLED(DELTA)
  plan_bed_level_matrix.set_to_identity(); 	// we don't do bed level correction in M48 because we wantthe raw data when we probe
#else
  reset_bed_level();	// we don't do bed level correction in M48 because we want the raw data when we probe
#endif
  if (Z_start_location < Z_RAISE_BEFORE_PROBING * 2.0)
    do_blocking_move_to_z(Z_start_location);
  do_blocking_move_to_xy(X_probe_location - X_PROBE_OFFSET_FROM_EXTRUDER, Y_probe_location - Y_PROBE_OFFSET_FROM_EXTRUDER);
  //
  // OK, do the initial probe to get us close to the bed.
  // Then retrace the right amount and use that in subsequent probes
  //
  setup_for_endstop_move();
  if (deploy_probe_for_each_reading)
    probe_pt(X_probe_location, Y_probe_location, Z_RAISE_BEFORE_PROBING, ProbeDeployAndStow, verbose_level);
  else
    probe_pt(X_probe_location, Y_probe_location, Z_RAISE_BEFORE_PROBING, ProbeDeploy, verbose_level);
  raise_z_after_probing();
  for (uint8_t n = 0; n < n_samples; n++) {
    randomSeed(millis());
    delay(500);
    if (n_legs) {
      int dir;
      double angle, radius;
      angle = random(0.0, 360.0);
      if (random(0, 10) > 5.0)  // clockwise or counter clockwise
        dir = -1;
      else
        dir =  1;
#if DISABLED(DELTA)
      radius = random(5, X_MAX_LENGTH / 8);
#else
      radius = random(DELTA_PROBEABLE_RADIUS / 8, DELTA_PROBEABLE_RADIUS / 3);
#endif
      if (verbose_level > 3) {
        SERIAL_ECHOPAIR("Starting radius: ", radius);
        SERIAL_ECHOPAIR("   angle: ", angle);
        delay(100);
        if (dir > 0)
          SERIAL_ECHO(" Direction: Counter Clockwise \n");
        else
          SERIAL_ECHO(" Direction: Clockwise \n");
        delay(100);
      }
      for (uint8_t l = 0; l < n_legs - 1; l++) {
        double delta_angle;
        if (schizoid_flag)
          delta_angle = dir * 2.0 * 72.0;	// The points of a 5 point star are 72 degrees apart.  We need to
        // skip a point and go to the next one on the star.
        else
          delta_angle = dir * (float) random(25, 45); 	// If we do this line, we are just trying to move further
        // around the circle.
        angle += delta_angle;
        while (angle > 360.0)	// We probably do not need to keep the angle between 0 and 2*PI, but the
          angle -= 360.0;		// Arduino documentation says the trig functions should not be given values
        while (angle < 0.0)		// outside of this range.   It looks like they behave correctly with
          angle += 360.0;		// numbers outside of the range, but just to be safe we clamp them.
        X_current = X_probe_location - X_PROBE_OFFSET_FROM_EXTRUDER + cos(RADIANS(angle)) * radius;
        Y_current = Y_probe_location - Y_PROBE_OFFSET_FROM_EXTRUDER + sin(RADIANS(angle)) * radius;
#if DISABLED(DELTA)
        X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
        Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
#else
        // If we have gone out too far, we can do a simple fix and scale the numbers
        // back in closer to the origin.
        while (sqrt(X_current * X_current + Y_current * Y_current) > DELTA_PROBEABLE_RADIUS) {
          X_current /= 1.25;
          Y_current /= 1.25;
          if (verbose_level > 3) {
            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
            SERIAL_ECHOPAIR(", ", Y_current);
            SERIAL_EOL;
            delay(50);
          }
        }
#endif
        if (verbose_level > 3) {
          SERIAL_PROTOCOL("Going to:");
          SERIAL_ECHOPAIR("x: ", X_current);
          SERIAL_ECHOPAIR("y: ", Y_current);
          SERIAL_ECHOPAIR("  z: ", current_position[Z_AXIS]);
          SERIAL_EOL;
          delay(55);
        }
        do_blocking_move_to_xy(X_current, Y_current);
      } // n_legs loop
    } // n_legs
    // We don't really have to do this move, but if we don't we can see a funny shift in the Z Height
    // Because the user might not have the Z_RAISE_BEFORE_PROBING height identical to the
    // Z_RAISE_BETWEEN_PROBING height.  This gets us back to the probe location at the same height that
    // we have been running around the circle at.
    do_blocking_move_to_xy(X_probe_location - X_PROBE_OFFSET_FROM_EXTRUDER, Y_probe_location - Y_PROBE_OFFSET_FROM_EXTRUDER);
    if (deploy_probe_for_each_reading)
      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, Z_RAISE_BEFORE_PROBING, ProbeDeployAndStow, verbose_level);
    else {
      if (n == n_samples - 1)
        sample_set[n] = probe_pt(X_probe_location, Y_probe_location, Z_RAISE_BEFORE_PROBING, ProbeStow, verbose_level); else
        sample_set[n] = probe_pt(X_probe_location, Y_probe_location, Z_RAISE_BEFORE_PROBING, ProbeStay, verbose_level);
    }
    //
    // Get the current mean for the data points we have so far
    //
    sum = 0.0;
    for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
    mean = sum / (n + 1);
    //
    // Now, use that mean to calculate the standard deviation for the
    // data points we have so far
    //
    sum = 0.0;
    for (uint8_t j = 0; j <= n; j++) {
      float ss = sample_set[j] - mean;
      sum += ss * ss;
    }
    sigma = sqrt(sum / (n + 1));
    if (verbose_level > 1) {
      SERIAL_PROTOCOL(n + 1);
      SERIAL_PROTOCOLPGM(" of ");
      SERIAL_PROTOCOL((int)n_samples);
      SERIAL_PROTOCOLPGM("   z: ");
      SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
      delay(50);
      if (verbose_level > 2) {
        SERIAL_PROTOCOLPGM(" mean: ");
        SERIAL_PROTOCOL_F(mean, 6);
        SERIAL_PROTOCOLPGM("   sigma: ");
        SERIAL_PROTOCOL_F(sigma, 6);
      }
    }
    if (verbose_level > 0) SERIAL_EOL;
    delay(50);
    do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
  }  // End of probe loop code
  // raise_z_after_probing();
  if (verbose_level > 0) {
    SERIAL_PROTOCOLPGM("Mean: ");
    SERIAL_PROTOCOL_F(mean, 6);
    SERIAL_EOL;
    delay(25);
  }
  SERIAL_PROTOCOLPGM("Standard Deviation: ");
  SERIAL_PROTOCOL_F(sigma, 6);
  SERIAL_EOL; SERIAL_EOL;
  delay(25);
  clean_up_after_endstop_move();
}

#endif
